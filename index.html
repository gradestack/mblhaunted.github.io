<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>you probably shouldn't use this but i'm running it in production</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, blinkmacsystemfont, 'segoe ui', roboto, oxygen, ubuntu, cantarell, sans-serif;
            line-height: 1.7;
            color: #1a1a1a;
            background: #f5f5f5;
            position: relative;
            overflow-x: hidden;
        }

        /* japanese wave background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.08;
            background-image:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 50px,
                    rgba(30, 64, 175, 0.4) 50px,
                    rgba(30, 64, 175, 0.4) 53px
                );
            background-size: 100% 100px;
            animation: wave 20s linear infinite;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background:
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(147, 197, 253, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(30, 64, 175, 0.1) 0%, transparent 50%);
        }

        @keyframes wave {
            0% {
                transform: translatex(0);
            }
            100% {
                transform: translatex(100px);
            }
        }

        .wave-svg {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 300px;
            z-index: -1;
            opacity: 0.15;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 100px rgba(0, 0, 0, 0.05);
            min-height: 100vh;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 30px;
            color: #1e3a8a;
            line-height: 1.2;
        }

        h2 {
            font-size: 1.8em;
            margin-top: 50px;
            margin-bottom: 20px;
            color: #1e40af;
            border-bottom: 2px solid rgba(30, 64, 175, 0.2);
            padding-bottom: 10px;
        }

        p {
            margin-bottom: 20px;
            font-size: 1.05em;
        }

        code {
            background: rgba(30, 64, 175, 0.08);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'monaco', 'menlo', monospace;
            font-size: 0.9em;
            color: #1e40af;
        }

        pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #3b82f6;
        }

        pre code {
            background: none;
            padding: 0;
            color: #e2e8f0;
        }

        ul {
            margin: 20px 0;
            padding-left: 30px;
        }

        li {
            margin: 10px 0;
        }

        strong {
            color: #1e40af;
        }

        hr {
            border: none;
            border-top: 1px solid rgba(30, 64, 175, 0.2);
            margin: 40px 0;
        }

        a {
            color: #2563eb;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        a:hover {
            border-bottom-color: #2563eb;
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin: 30px 0;
            border: 1px solid rgba(30, 64, 175, 0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        img:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.15);
        }

        .image-caption {
            text-align: center;
            font-size: 0.9em;
            color: #64748b;
            margin-top: -20px;
            margin-bottom: 30px;
            font-style: italic;
        }

        .wave-accent {
            width: 60px;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #93c5fd);
            margin: 30px 0;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <svg class="wave-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1200 120" preserveaspectratio="none">
        <path d="m0,0v46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5c438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34c989.49,25,1113-14.29,1200,52.47v0z" fill="rgba(59, 130, 246, 0.1)"/>
        <path d="m0,0v15.81c13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24v0z" fill="rgba(147, 197, 253, 0.15)"/>
    </svg>

    <div class="container">
        <div class="wave-accent"></div>

        <h1>you probably shouldn't use this but i'm running it in production</h1>

        <p>so claude code is great at single tasks. need a function? done. bug fix? easy. but the second you ask it to do something bigger like "build user authentication" or "add an api layer", it just... doesn't work well. you end up either babysitting it through every little step or it tries to do everything one at a time and takes forever.</p>

        <p>got annoying pretty fast. so i made <strong>waverunner</strong>.</p>

        <h2>what it does</h2>

        <p>you give it a goal like "add jwt authentication to my app." instead of claude just going for it, waverunner does this whole planning thing with different personas. there's a tech lead, senior dev, explorer, skeptic, and a maverick who basically argues with everyone.</p>

        <p>they argue it out. explorer's like "we don't know what auth is already there." skeptic goes "yeah what if there's existing code?" maverick challenges their time estimates. eventually they figure out a plan with all the tasks and what depends on what.</p>

        <p>then the good part: <strong>it runs everything that can run at the same time, at the same time.</strong></p>

        <p>like if you need database setup, auth system, and logging, those don't need each other. so waverunner just starts all three. when they finish, it moves to the next batch of tasks. everything that can be parallel, is parallel.</p>

        <pre><code>wave 1: [setup-db] [setup-auth] [setup-logging]  ← all at once
wave 2: [implement-users]                         ← waits for auth + db
wave 3: [implement-api] [implement-tests]         ← both at once
wave 4: [integration-tests]                       ← final one</code></pre>

        <p>there's a live dashboard with progress bars for each task, cost tracking, tokens per second. it's honestly fun to watch.</p>

        <h2>the self-healing part</h2>

        <p>after everything runs, it does a cleanup pass. removes your debug prints, test files, unused imports, all that stuff you'd have to clean up yourself. then claude looks at what got done and decides if the original goal was met.</p>

        <p>if not? makes a new plan and tries again. keeps going until it works or you stop it.</p>

        <h2>the reaper</h2>

        <p>this is honestly one of the cooler parts. there's a monitoring system called the reaper that watches all running tasks. if something hangs or goes silent for too long, it kills the task. but here's the thing - it doesn't just kill it and forget about it.</p>

        <p>it saves the "corpse." what the task was doing, how long it ran, what it was stuck on, any partial work it did. everything.</p>

        <p>when that task gets retried (and it will), the new agent sees all of this. "attempt #1: killed after 195s, was silent for 180s, got stuck on token validation. attempt #2: killed after 215s, tried jwt library but hit dependency issues."</p>

        <p>so the new agent knows exactly what not to do. won't try the same approach twice. actually learns from failures.</p>

        <p>it also catches thrashing. same task dies 3 times? or you're on iteration 5 and barely anything's done? the system detects this and forces the planning team to try something completely different. no more banging your head against the same wall.</p>

        <h2>when you'd use this</h2>

        <p>basically anytime you'd normally break something down for claude yourself.</p>

        <ul>
            <li>"add user authentication"</li>
            <li>"build a rest api for this data model"</li>
            <li>"refactor this auth system"</li>
            <li>"fix these bug reports"</li>
        </ul>

        <p>instead of walking claude through it piece by piece:</p>

        <pre><code>waverunner go "add user authentication with jwt"</code></pre>

        <p>that's it. plans it, runs it in parallel waves, cleans up after itself, checks if it worked, retries if needed.</p>

        <a href="waverunner1.png" target="_blank"><img src="waverunner1.png" alt="simple waverunner demo prompt"></a>
        <p class="image-caption">just give it a goal and let it run</p>

        <h2>the persona thing actually matters</h2>

        <p>so those personas aren't just for show. each one has a real job and they actually catch different problems.</p>

        <p>the <strong>explorer</strong> is there to flag unknowns before you waste time implementing the wrong thing. "do we even know what the current auth looks like?" that kind of stuff.</p>

        <p><strong>skeptic</strong> questions assumptions. "what if there's already auth middleware we should use instead of writing new code?" saves you from reinventing wheels.</p>

        <p><strong>maverick</strong> is honestly the most useful one. challenges everything. "you estimated this as small but how do you know? what if the integration is way more complex?" forces the team to think harder about their plan.</p>

        <p><strong>tech lead</strong> keeps it moving and breaks stuff down. <strong>senior dev</strong> actually estimates complexity and pushes for simple solutions.</p>

        <p>there's also a kanban mode with different personas (flow master, kaizen voice, quality gate) based on toyota production system stuff. better for maintenance work than feature development.</p>

        <p>point is, they're not roleplay. each one catches different failure modes before you hit them.</p>

        <a href="waverunner2.png" target="_blank"><img src="waverunner2.png" alt="team planning session output"></a>
        <p class="image-caption">the planning team breaking down a task (spoiler: they eventually completed it successfully)</p>

        <h2>swappable models and mcp</h2>

        <p>you can use different llm providers. there's a provider abstraction so you're not locked into just claude. extend the <code>llmprovider</code> class and you can plug in whatever model you want.</p>

        <p>mcp integration is solid too. pass <code>--mcp</code> with a config file and every agent gets access to those tools. need to query a database? connect to an api? read from some external service? just inject the mcp server and all your agents can use it.</p>

        <pre><code>waverunner go "analyze this week's user signups" --mcp ~/database-mcp.json</code></pre>

        <p>the mcp config gets passed to every claude instance that spins up. so your explorer can investigate the database, your implementation tasks can query it, whatever. it just works.</p>

        <h2>spike tasks</h2>

        <p>this is a cool feature. if the team doesn't know something, they make "spike" tasks. basically just investigation work. the spike runs first, figures things out, and the findings get passed to whatever tasks need them. so you're not building blind.</p>

        <p>spikes run in their own workspace so you don't end up with test junk all over your actual project.</p>

        <h2>setup</h2>

        <p>nothing special:</p>

        <pre><code>git clone &lt;your-repo-url&gt;
cd waverunner
python3 -m venv .venv
source .venv/bin/activate
pip install -e .</code></pre>

        <p>need python 3.10+ and claude code cli installed.</p>

        <h2>does it work?</h2>

        <p>yeah it does. i mean it's not gonna fix an impossible task or a completely broken codebase. but for stuff that's too big for one prompt and too annoying to micromanage? big difference.</p>

        <p>just the parallel execution saves so much time. and the retry stuff means you don't get stuck with half-done work when something breaks.</p>

        <p>that's waverunner. if you use claude code for more than quick one-off stuff, try it out.</p>
    </div>
</body>
</html>
